getwd()
data = read.csv("garch_data.csv")
bitcoin = data[,2]
bitcoin.log = diff(log(bitcoin))
n = length(bitcoin.log)
bitcoin.window = bitcoin.log[305:n]
ts.plot(bitcoin.window)
n = length(bitcoin.window)
bitcoin.train = bitcoin.window[-c(104:n)]
bitcoin.test = bitcoin.window[104:n]
Box.test(bitcoin.train,type="Ljung-Box")
acf(bitcoin)
acf(bitcoin.log)
aic_optimal_order <- function(time_series) {
n = length(time_series)
p = c(1:5)
q = c(1:5)
d = c(0:3)
df_aic = data.frame(matrix(nrow = length(p)*length(q)*length(d), ncol = 4, 0))
index = 1
for(i in 1:length(p)){
for(j in 1:length(q)){
for(k in 1:length(d)){
tryCatch(
{
modijk = arima(time_series, order = c(p[i],d[k],q[j]), method='ML')
aic = modijk$aic - 2*(p[i]+q[j]+1) + 2*(p[i]+q[j]+1)*n/(n-p[i]-q[j]-2)
}, error = function(e) {
aic = 999999
}
)
df_aic[index, 1] = p[i]
df_aic[index, 2] = q[j]
df_aic[index, 3] = d[k]
df_aic[index, 4] = aic
index = index + 1
}
}
}
colnames(df_aic) = c("p", "q", "d", "aic")
plot(df_aic$aic,ylab="AIC values")
row_min = df_aic[which.min(df_aic$aic),]
return(row_min)
}
library(forecast)
auto.arima(bitcoin.train)
aic_optimal_order(bitcoin.train)
final.arima = arima(bitcoin.train,order=c(0,0,0))
final.arima
auto.arima(bitcoin.train)
auto.arima(bitcoin.train)
aic_optimal_order(bitcoin.train)
final.arima = arima(bitcoin.train,order=c(4,0,4))
resid = resid(final.arima)
resid
acf(resid)
acf(resid^2)
Box.test(resid^2,type="Ljung",fitdf=0,lag=1)
library(quantmod)
library(tseries)
library(fGarch)
library(mgcv)
library(rugarch)
final.bic = Inf
final.order = c(0,0)
for (p in 1:6) for (q in 1:6){
print(c(p,q))
spec = ugarchspec(variance.model=list(garchOrder=c(p,q)),
mean.model=list(armaOrder=c(0, 0), include.mean=T),
distribution.model="std")
fit = ugarchfit(spec, bitcoin.train,solver="hybrid")
current.bic = infocriteria(fit)[2]
if (current.bic < final.bic) {
final.bic = current.bic
final.order = c(p, q)
}
}
final.order
final.bic = Inf
final.order = c(0,0)
for (p in 0:4) for (q in 0:4){
print(c(p,q))
spec = ugarchspec(variance.model=list(garchOrder=c(1,1)),
mean.model=list(armaOrder=c(p, q), include.mean=T),
distribution.model="std")
fit = ugarchfit(spec, bitcoin.train,solver="hybrid")
current.bic = infocriteria(fit)[2]
if (current.bic < final.bic) {
final.bic = current.bic
final.order = c(p, q)
}
}
final.order
final.bic = Inf
final.order = c(0,0)
for (p in 1:6) for (q in 1:6){
print(c(p,q))
spec = ugarchspec(variance.model=list(garchOrder=c(p,q)),
mean.model=list(armaOrder=c(2, 4), include.mean=T),
distribution.model="std")
fit = ugarchfit(spec, bitcoin.train,solver="hybrid")
current.bic = infocriteria(fit)[2]
if (current.bic < final.bic) {
final.bic = current.bic
final.order = c(p, q)
}
}
spec.2 = ugarchspec(variance.model=list(garchOrder=c(2,1)),
mean.model=list(armaOrder=c(5, 5),
include.mean=T), distribution.model="std")
getwd()
data = read.csv("garch_data.csv")
bitcoin = data[,2]
n = length(bitcoin.log)
bitcoin.window = bitcoin.log[305:n]
ts.plot(bitcoin.window)
data = read.csv("garch_data.csv")
bitcoin = data[,2]
bitcoin.log = diff(log(bitcoin))
n = length(bitcoin.log)
bitcoin.window = bitcoin.log[305:n]
ts.plot(bitcoin.window)
bitcoin.log = diff((bitcoin))
n = length(bitcoin.log)
bitcoin.window = bitcoin.log[305:n]
ts.plot(bitcoin.window)
bitcoin = data[,2]
bitcoin.log = diff(log(bitcoin))
n = length(bitcoin.log)
bitcoin.window = bitcoin.log[305:n]
ts.plot(bitcoin.window)
Box.test(bitcoin.train,type="Ljung-Box")
bitcoin.window = bitcoin.log[305:n]
ts.plot(bitcoin.window)
n = length(bitcoin.window)
bitcoin.train = bitcoin.window[-c(104:n)]
bitcoin.test = bitcoin.window[104:n]
Box.test(bitcoin.train,type="Ljung-Box")
final.arima = arima(bitcoin.train,order=c(0,0,0))
resid = resid(final.arima)
acf(resid)
acf(resid^2)
Box.test(resid^2,type="Ljung",fitdf=0,lag=1)
Box.test(resid,type="Ljung",fitdf=0,lag=1)
